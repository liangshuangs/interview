# 跨站伪造请求
CSRF(cross site request forgery)
## 攻击原理
1. 主要归结于浏览器同源策略限制级别的问题
2. 对于Cookie、DOM和XMLHttpRequest所有的浏览器都会严格遵守同源策略，但是也有例外，比如 'img'标签，'script'标签，‘iframe’标签等的链接会自动加载，更重要的是，表单提交也是可以跨域的。
正是因为这些html标签和表单提交可以跨域问题，一些黑产在恶意站点设置了用户不感知的情况下发起了其他站点的请求，比如用户登陆了某支付网站后，不经意点开了某恶意站点，该站点自动请求某支付网站（浏览器会匹配domain和path自动带上了cookie凭证），此时就相当于黑产拿到了用户的身份凭证了。

# 浏览器的同源策略
## 什么叫同源？
协议、域名、端口有任何一个不同，就被当作是跨域。
## 为什么要同源策略？
换句话说就是浏览器禁止的是来自不同源的'document'或脚本，对当前'document'读取或者设置某些属性。
情景：
比如一个恶意的网站的页面通过iframe嵌入了银行的登陆页面（二者不同源），如果没有同源的限制，恶意网页上的javascript脚本就可以在用户登陆银行的时候获取用户名和密码。
## 浏览器中有哪些不受同源限制的呢？
script、img、iframe、link这些包含src属性的标签可以加载跨域资源，但是浏览器限制了javascript的权限使其不能读、写加载的内容。
## 为什么jsonp的script不受同源策略的限制？
当你打开一个网站时，这个网站开始脚本，会检测这个脚本的来源，如果这个脚本的来源与当前网站不同源的话，就会限制其执行。
那怎么判断脚本的来源呢？这个来源是怎么定义的呢？
脚本的来源取决于脚本说嵌入的资源的来源。
比如访问了A主机的当前的Html文件中有一个script标签，这个标签的src属性请求了一个js脚本，因为这个脚本是由A主机的html文件的嵌入的script标签发起请求获取的，因此这个脚本的来源是属于A主机的。

